library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity top is
    Port ( a,b : in STD_LOGIC;
           y : out STD_LOGIC);
end top;

architecture Behavioral of top is

begin

y<=a and b;
end Behavioral;

#VHDL HAS THREE PART 1:- WHERE IT SPECIFIES LIBRARY 2:-ENTITY 3:-ARCHITECTURE
#LIBRARY IEEE :-IEEE IS FOLDER PRESENT INSIDE A DIRECTORY WHERE YOU HAVE INSTALLED A VIVADO WHICH CONSIST OF A SET OF A LIBRARY.
#USE IEEE.STD_LOGIC_1164.ALL:-FROM THAT FOLDER WE ARE USING THIS LIBRARY.(LIBRARY IS SYSTEM INDEPENDENT BUT ENTITY AND ARCHITECTURE ARE SYSTEM DEPENDENT)


#after simulation we do the RTL analysis
#RTL ANALYSIS FOR SCHEMATIC
ENTITY(SPECIFIES ABOUT INPUT AND OUTPUT PORT AND ARCHITECTURE TELL ABOUT THE LOGIC)

#SINGLE BIT REPRESENTED AS STD_LOGIC
#FOR LAST I/O PORT WE DONOT ADD SEMICOLON
#SPACE BETWEEN ARCHITECTURE AND BEGIN IS SIGNAL ,COMPONENT ,MEMEORY ETC.
=< ASSIGNMENT OPERATOR.
#FOR MORE BIT std_logic_vector(3 downto 0);
std_logic_1164:-contains std_logic and all the logic operation
numeric_std (_logic_signed or-logic_unsigned):- all the artihmetic operation(input a\can be unsigned and signed data type an =d for both we need different hardwwware)
#PRIMITIVES ARE THE FUNDAMENTAL BLOCK WHICH ARE USE DTO DEVLOP THE CIRCUIT WHICH FPGA CAN UNDERSTAND
#THE PROCESS OF CONVERSION FROM FPGA CODE TO PRIMITIVES IS HANDLED USING SYNTHESIS
#NOW SYNTHESIS HAS TRANSFORMED OUR CODE TO SOMETHING THAT FPGA UNDERSATND NOW WE HAVE TO PUT THAT ENTIRE DESIGN ON FPGA DIE SO WE NEED TO SPECIFY INPU AND OUPUT PORT SO THAT THE TOOL 
IDENTIFY THE BEST PLACE TO PLACE OUR DESIGN.
#ADD A CONSTRAINT
#SCALAR PORTS
#save contraints
#implementation
#schematic there you will see blue dot or something showing our design
#bitstream generation
#programmming an fpga
#RTL View is a Register Transfer Level graphical representation of your design. 
This representation (.ngr file produced by Xilinx Synthesis Technology (XST)) is generated by the synthesis tool
at earlier stages of a synthesis process when technology mapping is not yet completed. 
The goal of this view is to be as close as possible to the original HDL code. In the RTL view, the 
design is represented in terms of macro blocks, such as adders, multipliers, and registers. Standard combinatorial logic is mapped onto logic gates, such as AND, NAND, and OR.

#Use of Post-Synthesis View
Graphical representation of the post-synthesis (“optimized and mapped“) netlist
(.ngc file produced by XST) contains Xilinx primitives as defined in the UNISIM library, such as LUTs, DCM, I/O buffers, and flip-flops. 
The Schematic Viewer allows you to visualize the primitive properties and the constraints attached to them.
#after bitsttream put on hardware manager
#open target auto connect


##other way for constraints we can first make an xdc file by going on to a folder of constraint clicking it thne add contraints and then copy master xdc file an dcopy in new xdc file
then replce with the switches led we want.
#to check the power consumption sythesis then implement the see power
#to have good implementation go to setting then to implementation then to post place power opt design (this option reduce power dissipate whn do dynamic clockingg)
 enable it
 
 
 #SYNTHESIS SETTING
 
 IT IS BAD TO SOMETHING BETWEEN THE CLOCK LINES AND ITS RESOURCE THUS TURNING ON GATE CLOCK CONVERSION THEN VIVADO WILL TRY TO REMOVE THIS GATE AND THEN APPLY SOMETHING
 WHICH IS IMPLEMENTED EASILY ON FPGA.
 FOR FSM EXTRACTION THERE ARE VARIOUS ENCODING
 
 
 #I/O PLANNING PROJECT
HERE HEXAGON REPRESENT CLOCKS
#IN HERE IF WE SELECT SOME AREA THEN THERE IS A DIRECT EFFECT ON A DIE 
FORE X IF WE HAVE 676 DESIGN WE CAN BLOCK REGION NOT AVAILABLE FOR LOWER PINS TRHROUGH I/O PLANNING
##THNE USING MIGRATE TO RTL WE SEE WE HAVE ALL OUR CONSTRAINTS

##signal 
cases whee wemight have to reuuse our output port then signal is used.
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


they are global variable any process can get acces to them


entity top is
    Port ( a : in STD_LOGIC;
           b : in STD_LOGIC;
           y : out STD_LOGIC);
end top;

architecture Behavioral of top is
signal temp: std_logic:='0';
begin
temp<=a and b;
y<=not temp;
end Behavioral;
##whenever there are undefined net there we have to use signal
#for value of signal>1 use "" i.e signal temp:std_logic_vector(3 downto 0):="0000";
#siganl temp:std_logic_vector(3 downto 0):=x"0000";each 0 means 0000;
#signal temp:std_logic_vector(255 downto 0):=(others=>'0');#most right way
#signal assignment<=






#variable


variable donot have the global scope it is defined between process and begin
assignment if odne using:=

In a sequential circuit  signal and variabe are different
in a combinational circuit signal and variable are same

#understanding type conversion and printing

#first we convert logic _vector to an unsigned or say signed
to integer is in numericstd.all
for procees begin if no parameter then we just be adding the wait as if not it may hang our system to infinite time

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;


entity top is
end top;

architecture top2 of top is
signal temp:std_logic_vector(3 downto 0):="1011";
signal data:integer range 0 to 30:=8;
begin
data<=to_integer(unsigned(temp));
process
begin
wait for 5 ns;
report "Value of data is" &integer'image(data);
wait;
end process;


end top2;


#DIFFERENT MODELLING STYLE IN AN VHDL

1.GATE LEVEL/DATAFLOW:- this is utilized to implement a simple combinational circuit or a basic logic gatei.e whenever we can replace our circuit by basic logic gate
2.BEHAVIORAL:-if yo are able to replace behaviour of the system i.e if you are able to form a truth table of your system i.e we donot know which all component are required but 
can predict the behaviour.say for mux we know for S0,S1 used to get the output also if form state diagram,for specific waveform .Also by defauult behavoral style.FSM
3.STRUCTURAL:-if you have your own component say half adder and you are reusing that component then we usit for building full adder also to implent large mux using smalll mux.
4.Switch level modelling style is not synthesizable/IP I.E IF WE CAN IMPLEMENT SYSTEM WITH NMOS OR PMOS OR CMOS.
so each system atleast has a four different ways of implementing.
ADVANTAGE OF RIGHT STYLE IS WE WILL BE ABLE TO CHOOSE SYSTEM WITH MINIMUM CODE.



HERE WE HAVE FOUR DIFFERENT TYPES OF AN ARCHITECTURE  BASICALLY FOUR DIIFFERENT WAY TO IMPLEMENT A SYSTEM
1.DRAW THE STATE DIAGRAM  2.BASIC LOGIC STRUCTURE (i.e REPLACE THE SYSTEM WITH THE BASIC LOGIC GATE 3.HERE WE HAVE ADDED A COMPONENT i.e HALF ADDER DEVELOPED BY US
THAT WE ARE USING TO BUILD A COMPLEX SYSTEM4.WE ARE ABLE TO BUILD A SYSTEM WITH PMOS AND NMOS.



### DATAA FLOW MODELLING STYLE
1. ALL NETS DEFNED IN THE ENTITY 
2.FEW NETS ARE UNDEFINED IN AN ENTITY

##REMEMBER ALL THE NETS ARE NEED STO BE DEFINED SAY FOR XOR NETS ARE DEFINED IN THE ENTITY BUT FOR
HALF ADDER NETS ARE NOT DEFINED IN ENTITY FOR THAT WE HAVE TO WRITE THE SIGNAL


3.CONDITIONAL SIGNAL ASSIGNMENT AND SELECTED SIGNAL ASSIGNMENT(THESE ALLOW TO IMPLEMENT SYSTEM WHOSE BEHAVIOUR IS KNOWN )


#HALF ADDER 
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


entity ha is
Port (a,b:in std_logic;
s,c:out std_logic );
end ha;

architecture Behavioral of ha is

begin

s<=a xor b;
c<=a and b;
end Behavioral;


##test bench when writing a test bench code first you have to design the instance that you are testing that can be done by using a component keyword.
now since entity has no port then how to generate stimuli and apply stimulus to design under test(DUT ) it is done by using the signal
#here for input we initialize the signal for output we donot


a of the haladder (component) we connect with a of signal
#using signal we create an instance using component we connect them

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


entity ha is
Port (a,b:in std_logic;
s,c:out std_logic );
end ha;

architecture Behavioral of ha is

begin

s<=a xor b;
c<=a and b;
end Behavioral;
--------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity hatb is
end hatb;
architecture hatb2 of hatb is
component ha is
Port (a,b:in std_logic;
s,c:out std_logic );
end component;
signal a,b:std_logic:='0';
signal s,c:std_logic;
begin
DUT:ha port map(a=>a,b=>b,s=>s,c=>c);
a<='1' after 10 ns,'1' after 20 ns,'0' after 20 ns,'1' after 50 ns;
b<='1' after 10 ns,'1' after 20 ns,'0' after 20 ns,'1' after 50 ns;
c<='1' after 10 ns,'1' after 20 ns,'0' after 20 ns,'1' after 50 ns;
end hatb2;
 


#generating clock signal for the input
i.e using force clock and force constant

clock_stimulus:process(a,b)
begin
a<=not a after 10ns;
b<=not b after 20 ns;
end process



#1 bit adder

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


entity fa is
Port (a,b,cin:in std_logic;
s,c:out std_logic );
end fa;

architecture Behavioral of fa is
signal t1,t2,t3:std_logic:='0';
begin
t1<=a xor b;
t2<=t1 and cin;
t3<= a and b;
s<=t1 xor cin;
c<= t2 or t3;

end Behavioral;
--------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity fatb is
end fatb;
architecture fatb2 of fatb is
component fa is
Port (a,b,cin:in std_logic;
s,c:out std_logic );
end component;
signal a,b,cin:std_logic:='0';
signal s,c:std_logic;
begin
DUT:fa port map(a=>a,b=>b,s=>s,cin=>cin);
clock_stimulus:process(a,b,cin)
begin
a<=not a after 10ns;
b<=not b after 20 ns;

end process;
end fatb2;
##binary to gray converter

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
 
 
 
entity bin2gray is
    Port ( b : in STD_LOGIC_VECTOR (3 downto 0);
           g : out STD_LOGIC_VECTOR (3 downto 0));
end bin2gray;
 
architecture Behavioral of bin2gray is
 
begin
g(3) <= b(3);
g(2) <= b(3) xor b(2);
g(1) <= b(2) xor b(1);
g(0) <= b(1) xor b(0);
 
 
end Behavioral;


##Conditional vs selected concurrent statement

#conditional
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
 
 
entity mux is
    Port ( a,b,c,d : in STD_LOGIC;
           ysc, ycs : out STD_LOGIC;
           sel : in STD_LOGIC_VECTOR (1 downto 0));
end mux;
 
architecture Behavioral of mux is
 
begin
Conditional Concurrent Signal Assg
ycc <= a when (sel = "00") else
     b when (sel = "01") else
     c when (sel = "10") else
     d when (sel = "11") else
     '0';
 so whenver we have series of implement ation in a conditional concurrrent signal asssignment we use if else
p:process(a,b,c,d,sel)
begin
if(sel = "00") then
 yie <= a;
 elsif (sel = "01") then
yie <= b;
elsif (sel = "10") then
yie <= c;
elsif (sel = "11") then
yie <= d;
else
yie <= '0';
end if;
end process;



#selcted assignment



with sel select
ysc <= a when "00",
     b when "01",
     c when "10",
     d when "11",
     '0' when others;
     
     #here we have a mux operated in parallel manner
--------------Case 
 
process(a,b,c,d,sel)
begin
case(sel) is 
when "00" =>
 ycs <= a;
when "01" =>
 ycs <= b;
 when "10" =>
 ycs <= c;
 when "11" =>
 ycs <= d;
 when others =>
 ycs <= '0'; 
end case;
end process;
 
end Behavioral;


GENERAGE STATEMENT basically replication of certain statemnet
for.....generate 
it generate the numbeer of copies  which is determined by the dicrete range
for continuous behaviour
label:for identifier in range generate(3 downto 0)(0 to 3 )for integer
{concrrent_statement}(behaviour)
end generate [label];#behaviojr is continous using for

## for loop
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


entity top is
 Port ( dout:out STD_LOGIC_VECTOR(11 downto 0));
end top;

architecture Behavioral of top is
signal a:std_logic_vector:="1010";
signal b:std_logic_vector:="1000";
signal c:std_logic_vector:="0011";
signal temp:std_logic_vector(11 downto 0);
begin
--//temp 0=> a(0) b(0) c(0) a(1) b(1) c(1)
gen_label:for i in 3 downto 0 generate
temp(3*i)<=a(i);
temp(3*i+1)<=b(i);
temp(3*i+2)<=c(i);
end generate;
dout<=temp;


end Behavioral;



if....generate
zero or copy is made conditionally
discontinity in the behaviour 
say shhift register from q3(last)to q0(first)
i.e ceratin block follw repeatitive pattern while some donot



#if loop


label:if expresssion generate
{concurrent statement}
end generate[label];
 here first we willl see the part which create discontinuity
 
 library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


entity top is
 Port ( dout:out STD_LOGIC_VECTOR(11 downto 0));
end top;

architecture Behavioral of top is

signal tempp:std_logic_vector(3 downto 0):="1100";
signal tempo:std_logic_vector(3 downto 0);
begin
--//temp 0=> a(0) b(0) c(0) a(1) b(1) c(1)
gen_label: for i in 3 downto 0 generate
g1:if(i=3) generate
 tempo(i)<=tempp(i-3);
 end generate g1;
g2:if (i<3) generate
tempo(i)<=tempp(i+1);
end generate g2;
end generate gen_label;
end Behavioral;
##DATATYPES
1. BIT
signal temp:bit:='1'
signal temp :bit_vector(2 downto 0):="001";

2.INTEGER
signal i1:integer range 0 to 99:=10;-- -2^32/2 to 2^32/2
process
variable my_line:line;
begin
write(my_line,i1);
writeline(output,my_line);
end tbnew;
end process;

3.natural
signal n1:natural range 0 to 23;

4 single bit multibit
signal s1:std_logic;
signal s2:std_logic_vector(4 downto 0):="10010"



##ARITHMETIC OPERATOR
+ ,-,* can be synthesizable only 
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;

ENTITY TB IS
END TB;
ARCHITECTURE TBNEW OF TB IS
signal a1:integer range 0 to 10:=5;
signal a2: integer range 0 to 10:=6;

begin
process
variable res1:integer range 0 to 20:=0;
variable res2:integer range 0 to 20:=0;
variable res3:integer range 0 to 20:=0;
begin
res1:=a1+a2;
res2:= a1-a2;
res3:=a1*a2;
end process;
end TBNEW;
library of use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
it is usefull if we use std_logic_vector and std_logic














# for VHDL 2008 shift operation

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity tb is
--  Port ( );
end tb;

architecture tbnew of tb is
signal temp1:std_logic_vector(3 downto 0):="1000";
signal temp2:std_logic_vector(3 downto 0):="1100";
signal res1:std_logic_vector(3 downto 0);
signal res2:std_logic_vector(3 downto 0);



begin
res1<=temp1 sll 1;#rol for rotate left
res2<=temp2 srl 2;#ror for rotate right

end tbnew;


#sla ,srl,sll,rol,srl,sra,ror
#RELATIONAL OPERATOR =,/=,>,>=,<,<=
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;

entity tb is
--  Port ( );
end tb;

architecture tbnew of tb is
signal temp1:std_logic_vector(3 downto 0):="1001";
signal temp2:std_logic_vector(3 downto 0):="1001";



begin
assert(temp1/=temp2) report "Two numbers are equal" SEVERITY NOTE;

end tbnew;


#DIVIDE BY TWO
library IEEE;

use IEEE.STD_LOGIC_1164.ALL;

use ieee.numeric_std.all;

use ieee.std_logic_unsigned.all;

entity tb is

--  Port ( );

end tb;

architecture tbnew of tb is

signal temp1:std_logic_vector(7 downto 0):="10000000";

signal res1:std_logic_vector(7 downto 0);

signal res2:std_logic_vector(7 downto 0);

signal res3:std_logic_vector(7 downto 0);

 

begin

res1<=temp1 srl 1;

res2<=temp1 srl 2;

res3<=temp1 srl 3;

end tbnew;

#BEHAVIOAL MODELLING STYLE
IT IS THE PREFFERED MODELLING STYLE
#LEARN COMBINATIONAL CIRCUIT FOR SEQUENTIAL ,WAVEFORM ,FSM.
BACKBONE OF IT IS THE PROCESS
#if we have combnational ckt all inout inside a circuit


#PROCESS
process()
begin
end process
library ieee;


use ieee.std_logic_1164.all;


entity top is
Port(a,b,clk,reset:in std_logic;
y:out std_logic);
end top;

architecture Behavioral of top is
begin
process(clk)--synchronous reset
processs(clk,reset)--asynchronous reset
begin

end process;
end behavioral;

combinational here output depend on all the input.process(a,b,c,d)
sequential :-ckt in which our system is sensitive to the fastest signal in this acase it is a clock signal .Synchronuous:-process(a,b,c,d) ;Asynchronous:-process(clk)

PROCESS IS A SYSTEM USED TO DEFINE YOUR SYSTEM SELECTIVITY AND SENSITIVITY
SENSITITVITY LIST MEANS YOUR SYSTEM OUTPUT WILL BE EVALUATED AS SOON AS input VARIABLE SPECIFIED IN process changes. 

 #IF ELSE#DEMUX
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
 
entity demux is
    Port ( din : in STD_LOGIC;
           a,b,c,d : out STD_LOGIC;
           sel : in STD_LOGIC_vector(1 downto 0));
end demux;
 
architecture Behavioral of demux is
-----component signal mem
begin
process(din,sel)
----variable
begin
a <= '0';
b <= '0';
c <= '0';
d <= '0';
 
if(sel = "00") then
a <= din;
elsif (sel = "01") then
b <= din;
elsif (sel = "10") then
c <= din;
elsif (sel = "11") then
d <= din;
else
null;
end if;
 
 
end process;
 
end Behavioral;

#also notice that jif you have not used a=0,b=0,c=0,d=0 it happens that only writing a<=din leads to the other value as the previous value


#MUX

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
 
entity demux is
    Port ( y : out STD_LOGIC;
           a,b,c : in STD_LOGIC;
           sel : in STD_LOGIC_vector(1 downto 0));
end demux;
 
architecture Behavioral of demux is
-----component signal mem
begin
process(a,b,c,sel)
----variable
begin
 
case (sel) is
when "00"=>
y<=a;
when "01"=>
y<=b;
when "10"=>
y<=c;
when "11"=>
y<='0';
end case;
end process;
 
end Behavioral;

#temp can also be used tto transmit the data after alll the operation to the dout pin

#7 SEGMENT DISPLAY

library ieee;
use ieee.std_logic_1164.all;
entity top is
Port(bin:in std_logic_vector(3 downto 0);
dout:out std_logic_vector(6 downto 0));
end top;

architecture behavioral of top is
signal temp:std_logic_vector(7 downto 0):=x"00";

begin
process(bin)--this is how we start combinational ckt
begin
case(bin) is
when "0000"=>
temp<=x"02";
when "0001"=>
temp<=x"9e";
when "0010"=>
temp<=x"24";
when "0011"=>
temp<=x"0C";
when "0100"=>
temp<=x"98";
when "0101"=>
temp<=x"48";
when "0110"=>
temp<=x"C0";
when "0111"=>
temp<=x"1E";
when "1000"=>
temp<=x"00";
when "1001"=>
temp<=x"18";
when others=>
temp<="ZZZZZZZZ";
end case;
end process;
dout<=temp(7 downto 1);
end behavioral ;




#GOOD PRACTICE IS TO ADD ALL THE REMAINIGN CASES TO REMOVE A LATCH.


#D FLIP FLOP


library ieee;
use ieee.std_logic_1164.all;
entity top is 
  port (clk:in std_logic;
        din:in std_logic;
        dout:out std_logic);
end top;
 architecture Behavioral of top is
  begin
  process(clk)
  begin
  if Rising_edge(clk)then--falling_edge
  dout<=din;
  end if;
  end process;
  end Behavioral;     



#SYNCHRONOUS RESET



library ieee;
use ieee.std_logic_1164.all;
entity top is 
  port (clk,rst:in std_logic;
        din:in std_logic;
        dout:out std_logic);
end top;
 architecture Behavioral of top is
  begin
  process(clk)
  begin
  if rising_edge(clk)then--falling_edge
   if rst='1' then
   dout<='0';
   else
    dout<=din;
  end if;
  end if;
  end process;
  end Behavioral;     



#ASYNCHRONOUS RESET

library ieee;
use ieee.std_logic_1164.all;
entity top is 
  port (clk,rst:in std_logic;
        din:in std_logic;
        dout:out std_logic);
end top;
 architecture Behavioral of top is
  begin
  process(clk,rst)
  begin
  IF rst='1' then
   dout<='0';
   
   elsif rising_edge(clk)then--falling_edge
   
    dout<=din;
  end if;
  end process;
  end Behavioral;     

#for both up down counter



library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity top is 
  port (clk,rst:in std_logic;   
        up:in std_logic;
  
        dout:out std_logic_vector(7 downto 0));
end top;
 architecture Behavioral of top is
 signal temp:std_logic_vector(7 downto 0):=x"00";
  begin
  process(clk)
  begin
  
  if rising_edge(clk) then
  if rst='1' then
  temp<=x"00";
  else
  if up='1'then
  temp<=temp+1;
  elsif up='0' then
  temp<=temp-1; 
  end if;
  end if;
  end if;
  end process;
  dout<=temp;
  end Behavioral;     

#PRIORITY ENCODER 8:3



library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


entity prien is
    Port ( d0 : in STD_LOGIC;
           d1 : in STD_LOGIC;
           d2 : in STD_LOGIC;
           d3 : in STD_LOGIC;
           d4 : in STD_LOGIC;
           d5 : in STD_LOGIC;
           d6 : in STD_LOGIC;
           d7 : in STD_LOGIC;
           Q0 : out STD_LOGIC;
           Q1 : out STD_LOGIC;
           Q2 : out STD_LOGIC);
end prien;

architecture Behavioral of prien is

begin
process(d0,d1,d2,d3,d4,d5,d6,d7)
begin
if d0='1' and d1='0'and d2='0'and d3='0'and d4='0'and d5='0'and d6='0'and d7='0'then
 Q0<='0';
 Q1<='0';
 Q2<='0';
elsIF d1='1' and (d0='0' or d0='1')and d2='0'and d3='0'and d4='0'and d5='0'and d6='0'and d7='0' then
 Q0<='1';
 Q1<='0';
 Q2<='0';
 elsIF d2='1' and (d0='0' or d0='1')and (d1='0' or d1='1')and d3='0'and d4='0'and d5='0'and d6='0'and d7='0' then
  Q0<='0';
 Q1<='1';
 Q2<='0';
 elsIF d3='1' and (d0='0' or d0='1')and (d1='0' or d1='1')and (d2='0' or d2='1') and d4='0'and d5='0'and d6='0'and d7='0'then
  Q0<='1';
 Q1<='1';
 Q2<='0';
 elsIF d4='1' and (d0='0' or d0='1')and (d1='0' or d1='1')and (d2='0' or d2='1')and (d3='0' or d3='1') and d5='0'and d6='0'and d7='0'then 
 Q0<='0';
 Q1<='0';
 Q2<='1';
 elsIF d5='1' and (d0='0' or d0='1')and (d1='0' or d1='1')and (d2='0' or d2='1')and (d3='0' or d3='1')and (d4='0' or d4='1') and d6='0'and d7='0'then
  Q0<='1';
 Q1<='0';
 Q2<='1';
 elsIF d6='1' and (d0='0' or d0='1')and (d1='0' or d1='1')and (d2='0' or d2='1')and (d3='0' or d3='1')and (d4='0' or d4='1')and (d5='0' or d5='1')and d7='0' then
  Q0<='0';
 Q1<='1';
 Q2<='1';
 
elsIF d7='1' and (d0='0' or d0='1')and (d1='0' or d1='1')and (d2='0' or d2='1')and (d3='0' or d3='1')and (d4='0' or d4='1')and (d5='0' or d5='1')and (d6='0' or d6='1') then
 Q0<='1';
 Q1<='1';
 Q2<='1';
 end if ;
 end process;
end Behavioral;



#TEST BENCH

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
 
entity top is
port (
a,b : in bit_vector(3 downto 0);
y : out bit_vector(3 downto 0)
 );
end top;
 
architecture Behavioral of top is
 
begin
 
y <= a or b;
 
end Behavioral;




library ieee;
use ieee.std_logic_1164.all;


entity toptb is
end toptb;
architecture toptb2 of toptb is
component top is
port (
a,b : in bit_vector(3 downto 0);
y : out bit_vector(3 downto 0));
end component;
signal a,b:bit_vector(3 downto 0):="0000";
signal y:bit_vector(3 downto 0);

 begin
 T1: top port map(a => a,b=> b,y=>y);
 
end toptb2 ;



#FORCE CONSTANT# here a beloww tb is of signal 
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
 
entity top is
port (
a,b : in bit_vector(3 downto 0);
y : out bit_vector(3 downto 0)
 );
end top;
 
architecture Behavioral of top is
 
begin
 
y <= a or b;
 
end Behavioral;




library ieee;
use ieee.std_logic_1164.all;


entity toptb is
end toptb;
architecture toptb2 of toptb is
component top is
port (
a,b : in bit_vector(3 downto 0);
y : out bit_vector(3 downto 0));
end component;
signal a,b:bit_vector(3 downto 0):="0000";
signal y:bit_vector(3 downto 0);

 begin
 T1: top port map(a => a,b=> b,y=>y);
 a<="0110" after 10 ns,"1010" after 20 ns,"0100" after 30 ns;
 b<="1111" after 10 ns,"0110" after 20 ns,"1000" after 30 ns;
end toptb2 ;






#FORCE CONSTANT WITH USE OF PROCESS

after same as before 
-- a<="0110" after 10 ns,"1010" after 20 ns,"0100" after 30 ns;
-- b<="1111" after 10 ns,"0110" after 20 ns,"1000" after 30 ns;
process
begin
wait for 10 ns;
a<="0110";
b<="1010";
wait for 10 ns;
a<="1010";
b<="0110";
wait for 10 ns;
a<="0100";
b<="1000";
wait for 10 ns;#if we wish we can do this
wait;#this extra wait or helping proces qith not to got to infifnti loop
end process;
end toptb2 ;

 
 #FORCE CLOCK 
 
 
 process(a)
begin 
a(0)<=not a(0) after 10 ns;
a(1)<=not a(1) after 20 ns;
a(2)<= not a(2) after 50 ns;
a(3) <= not a(3) after 40 ns;
end process;
process
begin
wait for 10 ns;

b<="1010";
wait for 20 ns;
b<="0110";
wait for 40 ns;
b<="1000";
wait for 50 ns;
wait;
end process;
end toptb2 ;

 
 #prefer to go with the force clock when we have a single bit signal
 
 
 #PROCEDURE 
 
 
 #between architecture and begin we can add a procedure
 library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;

 
entity top is

end top;
 
architecture Behavioral of top is#declare after architecture and before begin
 procedure tutorial(ir:in std_logic_vector(31 downto 0);
                     d:out std_logic_vector(31 downto 0)                
                     ) is   #we donot add any semicolon
begin
d:=ir+12;
 end tutorial;#this complete the processor.
 signal i,io:std_logic_vector(31 downto 0):=(others=>'0');#sginal i is where wwe apply the input
 begin
 process(i)
 variable temp:std_logic_vector(31 downto 0):=(others=>'0');#since outpiut cannot directly connect to signal thus we create
 begin
 tutorial(i,temp);
io<=temp;#here we assign temp to a port
end process;
end Behavioral;


#ARRAY (IT IS THE COLLECTION OF OBJECT OF THE SAME TYPE .SAME TYPE CAN BE (STD_LOGIC,STD_BIT,BIT)
TYPE (type_name) IS ARRAY(SPECIFICATION)OF data_Type#specification is th range say (0 to4 ) #data type is the bit ,std_logic,std_bit_vector;#by this we define an aray 
#how to use the arrray
signal signal_name:typename:=(intial values);
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;

entity Arrays is
port
(array_out:out std_logic_vector(7 downto 0)
);
end entity Arrays;

architecture Behavioral of Arrays is
Type hdl_learning is Array (0 to 3) of std_logic_vector(7 downto 0);
signal  check : hdl_learning :=("00000000","00000001","00000010","00000011");

begin 

array_out<=check(0);

 end Behavioral; 

                                                                                                                                                                        




 
 #RECORD 
 
 
 
 
 
 library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;

 
entity top is

end top;
 
architecture Behavioral of top is
type record1 is record#here wwe have multiple datatype
a,b :std_logic;
c,d: std_logic;
end record;
constant stimuli : record1 :=('1','0','1','1');#access the data we declare an instance stimuli for it datatype of record1
signal a1,a2,a3:std_logic;
begin
a1<=stimuli.c;
a2<=stimuli.d;
a3<=stimuli.b;
end Behavioral;







#for multibit vector



library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;

 
entity top is

end top;
 
architecture Behavioral of top is
type record1 is record
a,b :std_logic;
c,d: std_logic_vector(3 downto 0);
end record;
constant stimuli : record1 :=('1','0',"1011","1110");
signal a1,a2:std_logic;
signal b1,b2:std_logic_vector(3 downto 0);
begin
a1<=stimuli.a;
a2<=stimuli.b;
b1<=stimuli.c;
b2<=stimuli.d;
end Behavioral;


#counter


library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;

entity counter is
Port(rst,clk,dwn:in std_logic;
dout:out std_logic_vector(3 downto 0)
);end counter;
architecture count_arch of counter is
signal count:std_logic_vector(3 downto 0):="0000";
begin
process(rst,clk)
begin
if (rst='1') then
count<="0000";
elsif (clk'event and clk='1') then
if (dwn='1') then
count<=count-1;
else
count<=count+1;
end if;
end if;
end process;
end count_arch;



library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;

entity counttb is
end counttb;


architecture Behavioral of counttb is
signal rst,clk,dwn:std_logic:='0';
signal dout:std_logic_vector(3 downto 0);
component counter is
Port(rst,clk,dwn:in std_logic;
dout:out std_logic_vector(3 downto 0)
);end component;

begin
C1: counter port map(rst=>rst,clk=>clk,dwn=>dwn,dout=>dout);
clkprocess:process(clk)
begin
clk<=not clk after 10ns;
end process;
control_process:process
begin
rst<='1';
wait for 50 ns;
rst<='0';
dwn<='1';
wait for 200 ns;
dwn<='0';
wait for 50 ns;
rst<='1';
wait for 50 ns;
wait;
end process;
end behaviorial;





#USING IP  catelog  adder/subtractor
CUSTOMIZE IP










LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;



entity addtb is
--  Port ( );
end addtb;

architecture Behavioral of addtb is
component c_addsub_0 IS
  PORT (
    A : IN STD_LOGIC_VECTOR(14 DOWNTO 0);
    B : IN STD_LOGIC_VECTOR(14 DOWNTO 0);
    CLK : IN STD_LOGIC;
    CE : IN STD_LOGIC;
    C_OUT : OUT STD_LOGIC;
    S : OUT STD_LOGIC_VECTOR(14 DOWNTO 0)
  );
END component;
signal a,b :std_logic_vector(14 downto 0):=(others=>'0');
signal clk,ce:std_logic:='0';
signal c_out:std_logic;
signal s:std_logic_vector(14 downto 0);
begin
A1:c_addsub_0 port map(a=>a,b=>b,clk=>clk,ce=>ce,c_out=>c_out,s=>s);
process(clk)
begin
clk<=not clk after 10 ns;
end process;
process
begin
a<="10001010101010";
b<="10001010101010";
wait for 30 ns;
a<="10001010101010";
b<="10001010101010";
wait for 30 ns;

wait;
end process;
process
begin
ce<='1';
wait for 190ns;
ce<='0';
wait for 50 ns;


wait;
end process;

end Behavioral;













#STRUCTURAL MODELING STYLE

#TARGET IS TO UNDERSTAND HOW WE DECLARE AN IMPLICIT WAY OF MAPPING OUR CODE,EXPLICIT WAY ,ALSO HOW WE USE VIVADO IPI ALSO ,HOW WE HANDLE DEFINED AND UNDEFINED NET,
STRUCTURAL MODELLING STYLE SKELETON
#THERE ARE TWO NETS CALLED DEFOINED AND UNDEFINED NET IN A VHDL CODE SIGNAL ARE USED
TO DECLAR
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


entity ha is
    Port ( a,b : in STD_LOGIC;
           s,c : out STD_LOGIC);
end ha;

architecture Behavioral of ha is

begin
s<=a xor b;
c<=a and b;


end Behavioral;


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;



entity fa is
    Port ( a,b,cin : in STD_LOGIC;
           s,c : out STD_LOGIC);
end fa;

architecture Behavioral of fa is
component ha is
    Port ( a,b : in STD_LOGIC;
           s,c : out STD_LOGIC);
end component;
signal t1,t2,t3:std_logic:='0';
begin
H1: ha port map(a,b,t1,t2);#REFEREED AS AN IMPLICIT WAY OF DECLARING A PORT
H2: ha port map(t1,cin,s,t3);
c<=t2 or t3;
end Behavioral;













#structutal modeling style 32:! mux using 8:1mux









library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity mux is
    Port ( d0 : in STD_LOGIC;
           d1 : in STD_LOGIC;
           d2 : in STD_LOGIC;
           d3 : in STD_LOGIC;
           d4 : in STD_LOGIC;
           d5 : in STD_LOGIC;
           d6 : in STD_LOGIC;
           d7 : in STD_LOGIC;
           s0,s1,s2 : in STD_LOGIC;
           dout: out std_logic
           );
end mux;
architecture Behavioral of mux is
signal temp: std_logic;
signal sel: std_logic_vector(2 downto 0);
begin
sel(0) <=s0;
sel(1) <=s1;
sel(2) <=s2;
process(d0,d1,d2,d3,d4,d5,d6,d7,sel)
begin

case (sel) is
when "000" =>
temp<=d0;
when "001" =>
temp<=d1;
when "010" =>
temp<=d2;
when "011" =>
temp<=d3;
when "100" =>
temp<=d4;
when "101" =>
temp<=d5;
when "110" =>
temp<=d6;
when "111" =>
temp<=d7;
when others=>
temp<='0';
end case;
end process;
dout<=temp;
end Behavioral;



#design_1_wrapper.vhd




library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
library UNISIM;
use UNISIM.VCOMPONENTS.ALL;
entity design_1_wrapper is
  port (
    d0 : in STD_LOGIC;
    d0_1 : in STD_LOGIC;
    d0_2 : in STD_LOGIC;
    d0_3 : in STD_LOGIC;
    d1 : in STD_LOGIC;
    d1_1 : in STD_LOGIC;
    d1_2 : in STD_LOGIC;
    d1_3 : in STD_LOGIC;
    d2 : in STD_LOGIC;
    d2_1 : in STD_LOGIC;
    d2_2 : in STD_LOGIC;
    d2_3 : in STD_LOGIC;
    d3 : in STD_LOGIC;
    d3_1 : in STD_LOGIC;
    d3_2 : in STD_LOGIC;
    d3_3 : in STD_LOGIC;
    d4 : in STD_LOGIC;
    d4_1 : in STD_LOGIC;
    d4_2 : in STD_LOGIC;
    d4_3 : in STD_LOGIC;
    d5 : in STD_LOGIC;
    d5_1 : in STD_LOGIC;
    d5_2 : in STD_LOGIC;
    d5_3 : in STD_LOGIC;
    d6 : in STD_LOGIC;
    d6_1 : in STD_LOGIC;
    d6_2 : in STD_LOGIC;
    d6_3 : in STD_LOGIC;
    d7 : in STD_LOGIC;
    d7_1 : in STD_LOGIC;
    d7_2 : in STD_LOGIC;
    d7_3 : in STD_LOGIC;
    dout : out STD_LOGIC;
    s0 : in STD_LOGIC;
    s0_1 : in STD_LOGIC;
    s1 : in STD_LOGIC;
    s1_1 : in STD_LOGIC;
    s2 : in STD_LOGIC
  );
end design_1_wrapper;

architecture STRUCTURE of design_1_wrapper is
  component design_1 is
  port (
    s0 : in STD_LOGIC;
    s1 : in STD_LOGIC;
    s2 : in STD_LOGIC;
    dout : out STD_LOGIC;
    d0 : in STD_LOGIC;
    d0_1 : in STD_LOGIC;
    d1 : in STD_LOGIC;
    d2 : in STD_LOGIC;
    d3 : in STD_LOGIC;
    d4 : in STD_LOGIC;
    d5 : in STD_LOGIC;
    d6 : in STD_LOGIC;
    d7 : in STD_LOGIC;
    d1_1 : in STD_LOGIC;
    d2_1 : in STD_LOGIC;
    d3_1 : in STD_LOGIC;
    d4_1 : in STD_LOGIC;
    d5_1 : in STD_LOGIC;
    d6_1 : in STD_LOGIC;
    d7_1 : in STD_LOGIC;
    d0_2 : in STD_LOGIC;
    d1_2 : in STD_LOGIC;
    d2_2 : in STD_LOGIC;
    d3_2 : in STD_LOGIC;
    d4_2 : in STD_LOGIC;
    d5_2 : in STD_LOGIC;
    d6_2 : in STD_LOGIC;
    d7_2 : in STD_LOGIC;
    d0_3 : in STD_LOGIC;
    d1_3 : in STD_LOGIC;
    d2_3 : in STD_LOGIC;
    d3_3 : in STD_LOGIC;
    d4_3 : in STD_LOGIC;
    d5_3 : in STD_LOGIC;
    d6_3 : in STD_LOGIC;
    d7_3 : in STD_LOGIC;
    s0_1 : in STD_LOGIC;
    s1_1 : in STD_LOGIC
  );
  end component design_1;
begin
design_1_i: component design_1
     port map (
      d0 => d0,
      d0_1 => d0_1,
      d0_2 => d0_2,
      d0_3 => d0_3,
      d1 => d1,
      d1_1 => d1_1,
      d1_2 => d1_2,
      d1_3 => d1_3,
      d2 => d2,
      d2_1 => d2_1,
      d2_2 => d2_2,
      d2_3 => d2_3,
      d3 => d3,
      d3_1 => d3_1,
      d3_2 => d3_2,
      d3_3 => d3_3,
      d4 => d4,
      d4_1 => d4_1,
      d4_2 => d4_2,
      d4_3 => d4_3,
      d5 => d5,
      d5_1 => d5_1,
      d5_2 => d5_2,
      d5_3 => d5_3,
      d6 => d6,
      d6_1 => d6_1,
      d6_2 => d6_2,
      d6_3 => d6_3,
      d7 => d7,
      d7_1 => d7_1,
      d7_2 => d7_2,
      d7_3 => d7_3,
      dout => dout,
      s0 => s0,
      s0_1 => s0_1,
      s1 => s1,
      s1_1 => s1_1,
      s2 => s2
    );
end STRUCTURE;


















#FSM 

MEALY 3 PROCESSS 





library IEEE;
use IEEE.STD_LOGIC_1164.ALL;



entity TP is
    Port ( clk ,din: in STD_LOGIC;
           rst : in STD_LOGIC;
           dout : out STD_LOGIC);
end TP;

architecture Behavioral of TP is
type state_type is (s0,s1);
signal state,next_state:state_type:=s0;

begin
reset_logic:process(clk)
begin
if rising_edge(clk) then
if rst='1' then
state<=s0;
else
state<=next_state;
END IF;
END IF;
end process;
next_state_logic:process(din,state)
begin
case(state) is 
when s0=>
if (din ='1') then
next_state<=s1;
else
next_state<=s0;
end if;
when s1=>
if (din='0') then
next_state<=s1;
else 
next_state<=s0;
end if;
when others=>
next_state<=s0;
end case;
end process;
output_logic:process(din,state)
begin
case(state) is
when s0=>
if (din='1') then
dout<='0';
else
dout<='0';
end if;
when s1=>
if (din='1') then
dout<='1';
else
dout<='0'; 
end if;
end case;
end process;

end Behavioral;


#TWO PROCESSS MOORE MACHINE
 
 
 
 library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


entity TP is
    Port ( clk ,din: in STD_LOGIC;
           rst : in STD_LOGIC;
           dout : out STD_LOGIC);
end TP;

architecture Behavioral of TP is
type state_type is (s0,s1);
signal state,next_state:state_type:=s0;

begin
reset_logic:process(clk)
begin
if rising_edge(clk) then
if rst='1' then
state<=s0;
else
state<=next_state;
END IF;
END IF;
end process;
next_state_logic:process(din,state)
begin
case(state) is 
when s0=>
if (din ='1') then
next_state<=s1;
dout<='0';
else
next_state<=s0;
dout<='0';
end if;
when s1=>
if (din='0') then
next_state<=s1;
dout<='0';
else 
next_state<=s0;
dout<='1';
end if;
when others=>
next_state<=s0;
end case;
end process;

end Behavioral;

#one process mealy machine
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


entity TP is
    Port ( clk ,din: in STD_LOGIC;
           rst : in STD_LOGIC;
           dout : out STD_LOGIC);
end TP;

architecture Behavioral of TP is
type state_type is (s0,s1);
signal state:state_type:=s0;

begin
reset_logic:process(clk)
begin
if rising_edge(clk) then
if rst='1' then
state<=s0;
else
case(state) is
when s0=>
if (din ='1') then
state<=s1;
dout<='0';
else
state<=s0;
dout<='0';
end if;
when s1=>
if (din='0') then
state<=s1;
dout<='0';
else 
state<=s0;
dout<='1';
end if;
when others=>
state<=s0;
dout<='0';
end case;
end if;
end if;
end process;

end Behavioral;







#3 PROCESS MOORE MACHINE




library IEEE;
use IEEE.STD_LOGIC_1164.ALL;



entity MOORE is
    Port ( clk : in STD_LOGIC;
           rst : in STD_LOGIC;
           dout : out STD_LOGIC;
           din : in STD_LOGIC);
end MOORE;

architecture Behavioral of MOORE is
type state_type is (s0,s1);
signal state,next_state:state_type:=s0;

begin

reset:process(clk)
begin
if rising_edge(clk)then
if (rst='1') then
state<=s0;
else 
state<=next_state;
end if;
end if;
end process;


  
process(state,din)
begin
case(state) is
when  s0 =>
if din='1' then
next_state<=s1;
else
next_state<=s0;
end if;
when  s1 =>
if din='1' then
next_state<=s0;
else
next_state<=s1;
end if;
end case;
end process;

output_logic:process(state)
begin
if state=s0 then
dout<='0';
elsif state=s1 then
dout<='1';
else
dout<='0';
end if;
end process;


end Behavioral;





#2 PROCESS MOORE MACHINE

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;



entity MOORE is
    Port ( clk : in STD_LOGIC;
           rst : in STD_LOGIC;
           dout : out STD_LOGIC;
           din : in STD_LOGIC);
end MOORE;

architecture Behavioral of MOORE is
type state_type is (s0,s1);
signal state,next_state:state_type:=s0;

begin

reset:process(clk)
begin
if rising_edge(clk)then
if (rst='1') then
state<=s0;
else 
state<=next_state;
end if;
end if;
end process;


  
process(state,din)
begin
case(state) is
when  s0 =>
dout<='0';
if din='1' then
next_state<=s1;
else
next_state<=s0;
end if;
when  s1 =>
dout<='1';
if din='1' then
next_state<=s0;
else
next_state<=s1;
end if;
when others =>
dout<='0';
next_state<=s0;

end case;
end process;



end Behavioral;




#SINGLE PROCESS METHODOLOGY



library IEEE;
use IEEE.STD_LOGIC_1164.ALL;



entity MOORE is
    Port ( clk : in STD_LOGIC;
           rst : in STD_LOGIC;
           dout : out STD_LOGIC;
           din : in STD_LOGIC);
end MOORE;

architecture Behavioral of MOORE is
type state_type is (s0,s1);
signal state:state_type:=s0;

begin

reset:process(clk)
begin
if rising_edge(clk)then
if (rst='1') then
state<=s0;
else 
case(state) is
when  s0 =>
dout<='0';
if din='1' then
state<=s1;
else
state<=s0;
end if;
when  s1 =>
dout<='1';
if din='1' then
state<=s0;
else
state<=s1;
end if;
when others=>
dout<='0';
state<=s0;
end case ;
end if ;
end if ;
end process;
end Behavioral;





#OVERLAPPING SSEQUENCE DETECTOR


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
 
 
entity top is
    Port ( clk,rst, din : in STD_LOGIC;
           dout : out STD_LOGIC);
end top;
 
architecture Behavioral of top is
type state_type is (s0,s1,s2,s3);
signal state, next_state : state_type := s0;
begin
 
reset_logic: process(clk)
begin
if(rising_edge(clk)) then
   if(rst = '1') then
     state <= s0;
   else 
     state <= next_state;
   end if;
end if;
end process;
 
next_state_logic: process(state,din)
begin
case(state) is
when s0 => 
 if(din = '1') then
    next_state <= s1;
    dout <= '0';
 else
    next_state <= s0;
    dout <= '0';
 end if;
     
when s1 => 
 if(din = '0') then
    next_state <= s2;
    dout <= '0';   
 else
    next_state <= s1;
    dout <= '0';   
 end if;
 
 when s2 => 
 if(din = '1') then
    next_state <= s3;
    dout <= '0';   
 else
    next_state <= s0;
    dout <= '0';   
 end if;
 
 
 when s3 => 
 if(din = '1') then
    next_state <= s1;
    dout <= '1';   
 else
    next_state <= s2;
    dout <= '0';   
 end if;
 
 when others =>
   next_state <= s0;
   dout <= '0';
    
end case;
end process;
end Behavioral;








#TRAFFIC CONTROL 

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;



entity tf is
    Port ( clk : in STD_LOGIC;
           rst : in STD_LOGIC;
           r : out STD_LOGIC;
           y : out STD_LOGIC;
           g : out STD_LOGIC);
end tf;

architecture Behavioral of tf is
type state_type is (idle,s0,s1,s2);
signal state:state_type:=s0;
signal count: integer range 0 to 10:=0;
begin
process(clk)
begin
if rising_edge(clk) then
  if rst='1' then
    state<=idle;
   else
   case(state) is
   when idle=>
   r<='0';
   y<='0';
   g<='0';
   state<=s0;
   when s0=>
   r<='1';
   y<='0';
   g<='0';
   if count<5 then
   count<=count+1;
   state<=s0;
   else
   count<=0;
   state<=s1;
   end if;
   
   when s1=>
   r<='0';
   y<='1';
   g<='0';
   if count<3 then
   count<=count+1;
   state<=s1;
   else
   count<=0;
   state<=s2;
   end if;
   
   when s2=>
   r<='0';
   y<='0';
   g<='1';
   if count<7 then
   count<=count+1;
   state<=s2;
   else
   count<=0;
   state<=s0;
   end if;
   when others=>
   state<=s0;
   r<='0';
   y<='0';
   g<='0';
end case;
end if;
end if;
end process;
end Behavioral;


