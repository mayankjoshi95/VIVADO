# for VHDL 2008 shift operation

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity tb is
--  Port ( );
end tb;

architecture tbnew of tb is
signal temp1:std_logic_vector(3 downto 0):="1000";
signal temp2:std_logic_vector(3 downto 0):="1100";
signal res1:std_logic_vector(3 downto 0);
signal res2:std_logic_vector(3 downto 0);



begin
res1<=temp1 sll 1;#rol for rotate left
res2<=temp2 srl 2;#ror for rotate right

end tbnew;



#RELATIONAL OPERATOR =,/=,>,>=,<,<=
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;

entity tb is
--  Port ( );
end tb;

architecture tbnew of tb is
signal temp1:std_logic_vector(3 downto 0):="1001";
signal temp2:std_logic_vector(3 downto 0):="1001";



begin
assert(temp1/=temp2) report "Two numbers are equal" SEVERITY NOTE;

end tbnew;


#DIVIDE BY TWO
library IEEE;

use IEEE.STD_LOGIC_1164.ALL;

use ieee.numeric_std.all;

use ieee.std_logic_unsigned.all;

entity tb is

--  Port ( );

end tb;

architecture tbnew of tb is

signal temp1:std_logic_vector(7 downto 0):="10000000";

signal res1:std_logic_vector(7 downto 0);

signal res2:std_logic_vector(7 downto 0);

signal res3:std_logic_vector(7 downto 0);

 

begin

res1<=temp1 srl 1;

res2<=temp1 srl 2;

res3<=temp1 srl 3;

end tbnew;




#BEHAVOURAL MODELLING STYLE #IF ELSE#DEMUX
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
 
entity demux is
    Port ( din : in STD_LOGIC;
           a,b,c,d : out STD_LOGIC;
           sel : in STD_LOGIC_vector(1 downto 0));
end demux;
 
architecture Behavioral of demux is
-----component signal mem
begin
process(din,sel)
----variable
begin
a <= '0';
b <= '0';
c <= '0';
d <= '0';
 
if(sel = "00") then
a <= din;
elsif (sel = "01") then
b <= din;
elsif (sel = "10") then
c <= din;
elsif (sel = "11") then
d <= din;
else
null;
end if;
 
 
end process;
 
end Behavioral;




#MUX

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
 
entity demux is
    Port ( y : out STD_LOGIC;
           a,b,c : in STD_LOGIC;
           sel : in STD_LOGIC_vector(1 downto 0));
end demux;
 
architecture Behavioral of demux is
-----component signal mem
begin
process(a,b,c,sel)
----variable
begin
 
case (sel) is
when "00"=>
y<=a;
when "01"=>
y<=b;
when "10"=>
y<=c;
when "11"=>
y<='0';
end case;
end process;
 
end Behavioral;


#D FLIP FLOP


library ieee;
use ieee.std_logic_1164.all;
entity top is 
  port (clk:in std_logic;
        din:in std_logic;
        dout:out std_logic);
end top;
 architecture Behavioral of top is
  begin
  process(clk)
  begin
  if Rising_edge(clk)then--falling_edge
  dout<=din;
  end if;
  end process;
  end Behavioral;     



#SYNCHRONOUS RESET



library ieee;
use ieee.std_logic_1164.all;
entity top is 
  port (clk,rst:in std_logic;
        din:in std_logic;
        dout:out std_logic);
end top;
 architecture Behavioral of top is
  begin
  process(clk)
  begin
  if rising_edge(clk)then--falling_edge
   if rst='1' then
   dout<='0';
   else
    dout<=din;
  end if;
  end if;
  end process;
  end Behavioral;     



#ASYNCHRONOUS RESET

library ieee;
use ieee.std_logic_1164.all;
entity top is 
  port (clk,rst:in std_logic;
        din:in std_logic;
        dout:out std_logic);
end top;
 architecture Behavioral of top is
  begin
  process(clk,rst)
  begin
  IF rst='1' then
   dout<='0';
   
   elsif rising_edge(clk)then--falling_edge
   
    dout<=din;
  end if;
  end process;
  end Behavioral;     

#for both up down counter



library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity top is 
  port (clk,rst:in std_logic;   
        up:in std_logic;
  
        dout:out std_logic_vector(7 downto 0));
end top;
 architecture Behavioral of top is
 signal temp:std_logic_vector(7 downto 0):=x"00";
  begin
  process(clk)
  begin
  
  if rising_edge(clk) then
  if rst='1' then
  temp<=x"00";
  else
  if up='1'then
  temp<=temp+1;
  elsif up='0' then
  temp<=temp-1; 
  end if;
  end if;
  end if;
  end process;
  dout<=temp;
  end Behavioral;     

#PRIORITY ENCODER 8:3



library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


entity prien is
    Port ( d0 : in STD_LOGIC;
           d1 : in STD_LOGIC;
           d2 : in STD_LOGIC;
           d3 : in STD_LOGIC;
           d4 : in STD_LOGIC;
           d5 : in STD_LOGIC;
           d6 : in STD_LOGIC;
           d7 : in STD_LOGIC;
           Q0 : out STD_LOGIC;
           Q1 : out STD_LOGIC;
           Q2 : out STD_LOGIC);
end prien;

architecture Behavioral of prien is

begin
process(d0,d1,d2,d3,d4,d5,d6,d7)
begin
if d0='1' and d1='0'and d2='0'and d3='0'and d4='0'and d5='0'and d6='0'and d7='0'then
 Q0<='0';
 Q1<='0';
 Q2<='0';
elsIF d1='1' and (d0='0' or d0='1')and d2='0'and d3='0'and d4='0'and d5='0'and d6='0'and d7='0' then
 Q0<='1';
 Q1<='0';
 Q2<='0';
 elsIF d2='1' and (d0='0' or d0='1')and (d1='0' or d1='1')and d3='0'and d4='0'and d5='0'and d6='0'and d7='0' then
  Q0<='0';
 Q1<='1';
 Q2<='0';
 elsIF d3='1' and (d0='0' or d0='1')and (d1='0' or d1='1')and (d2='0' or d2='1') and d4='0'and d5='0'and d6='0'and d7='0'then
  Q0<='1';
 Q1<='1';
 Q2<='0';
 elsIF d4='1' and (d0='0' or d0='1')and (d1='0' or d1='1')and (d2='0' or d2='1')and (d3='0' or d3='1') and d5='0'and d6='0'and d7='0'then 
 Q0<='0';
 Q1<='0';
 Q2<='1';
 elsIF d5='1' and (d0='0' or d0='1')and (d1='0' or d1='1')and (d2='0' or d2='1')and (d3='0' or d3='1')and (d4='0' or d4='1') and d6='0'and d7='0'then
  Q0<='1';
 Q1<='0';
 Q2<='1';
 elsIF d6='1' and (d0='0' or d0='1')and (d1='0' or d1='1')and (d2='0' or d2='1')and (d3='0' or d3='1')and (d4='0' or d4='1')and (d5='0' or d5='1')and d7='0' then
  Q0<='0';
 Q1<='1';
 Q2<='1';
 
elsIF d7='1' and (d0='0' or d0='1')and (d1='0' or d1='1')and (d2='0' or d2='1')and (d3='0' or d3='1')and (d4='0' or d4='1')and (d5='0' or d5='1')and (d6='0' or d6='1') then
 Q0<='1';
 Q1<='1';
 Q2<='1';
 end if ;
 end process;
end Behavioral;



#TEST BENCH

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
 
entity top is
port (
a,b : in bit_vector(3 downto 0);
y : out bit_vector(3 downto 0)
 );
end top;
 
architecture Behavioral of top is
 
begin
 
y <= a or b;
 
end Behavioral;




library ieee;
use ieee.std_logic_1164.all;


entity toptb is
end toptb;
architecture toptb2 of toptb is
component top is
port (
a,b : in bit_vector(3 downto 0);
y : out bit_vector(3 downto 0));
end component;
signal a,b:bit_vector(3 downto 0):="0000";
signal y:bit_vector(3 downto 0);

 begin
 T1: top port map(a => a,b=> b,y=>y);
 
end toptb2 ;



#FORCE CONSTANT
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
 
entity top is
port (
a,b : in bit_vector(3 downto 0);
y : out bit_vector(3 downto 0)
 );
end top;
 
architecture Behavioral of top is
 
begin
 
y <= a or b;
 
end Behavioral;




library ieee;
use ieee.std_logic_1164.all;


entity toptb is
end toptb;
architecture toptb2 of toptb is
component top is
port (
a,b : in bit_vector(3 downto 0);
y : out bit_vector(3 downto 0));
end component;
signal a,b:bit_vector(3 downto 0):="0000";
signal y:bit_vector(3 downto 0);

 begin
 T1: top port map(a => a,b=> b,y=>y);
 a<="0110" after 10 ns,"1010" after 20 ns,"0100" after 30 ns;
 b<="1111" after 10 ns,"0110" after 20 ns,"1000" after 30 ns;
end toptb2 ;






#FORCE CONSTANT WITH USE OF PROCESS

after same as before 
-- a<="0110" after 10 ns,"1010" after 20 ns,"0100" after 30 ns;
-- b<="1111" after 10 ns,"0110" after 20 ns,"1000" after 30 ns;
process
begin
wait for 10 ns;
a<="0110";
b<="1010";
wait for 10 ns;
a<="1010";
b<="0110";
wait for 10 ns;
a<="0100";
b<="1000";
wait for 10 ns;
wait;
end process;
end toptb2 ;

 
 #FORCE CLOCK 
 
 
 process(a)
begin 
a(0)<=not a(0) after 10 ns;
a(1)<=not a(1) after 20 ns;
a(2)<= not a(2) after 50 ns;
a(3) <= not a(3) after 40 ns;
end process;
process
begin
wait for 10 ns;

b<="1010";
wait for 20 ns;
b<="0110";
wait for 40 ns;
b<="1000";
wait for 50 ns;
wait;
end process;
end toptb2 ;

 
 
 
 
 #PROCEDURE 
 
 
 
 library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;

 
entity top is

end top;
 
architecture Behavioral of top is
 procedure tutorial(ir:in std_logic_vector(31 downto 0);
                     d:out std_logic_vector(31 downto 0)                   ) is
begin
d:=ir+12;
 end tutorial;
 signal i,io:std_logic_vector(31 downto 0):=(others=>'0');
 begin
 process(i)
 variable temp:std_logic_vector(31 downto 0):=(others=>'0');
 begin
 tutorial(i,temp);
io<=temp;
end process;
end Behavioral;



 
 #RECORD 
 
 
 
 
 
 library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;

 
entity top is

end top;
 
architecture Behavioral of top is
type record1 is record
a,b :std_logic;
c,d: std_logic;
end record;
constant stimuli : record1 :=('1','0','1','1');
signal a1,a2,a3:std_logic;
begin
a1<=stimuli.c;
a2<=stimuli.d;
a3<=stimuli.b;
end Behavioral;







#for multibit vector



library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;

 
entity top is

end top;
 
architecture Behavioral of top is
type record1 is record
a,b :std_logic;
c,d: std_logic_vector(3 downto 0);
end record;
constant stimuli : record1 :=('1','0',"1011","1110");
signal a1,a2:std_logic;
signal b1,b2:std_logic_vector(3 downto 0);
begin
a1<=stimuli.a;
a2<=stimuli.b;
b1<=stimuli.c;
b2<=stimuli.d;
end Behavioral;








#USING IP  catelog  adder/subtractor










LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;



entity addtb is
--  Port ( );
end addtb;

architecture Behavioral of addtb is
component c_addsub_0 IS
  PORT (
    A : IN STD_LOGIC_VECTOR(14 DOWNTO 0);
    B : IN STD_LOGIC_VECTOR(14 DOWNTO 0);
    CLK : IN STD_LOGIC;
    CE : IN STD_LOGIC;
    C_OUT : OUT STD_LOGIC;
    S : OUT STD_LOGIC_VECTOR(14 DOWNTO 0)
  );
END component;
signal a,b :std_logic_vector(14 downto 0):=(others=>'0');
signal clk,ce:std_logic:='0';
signal c_out:std_logic;
signal s:std_logic_vector(14 downto 0);
begin
A1:c_addsub_0 port map(a=>a,b=>b,clk=>clk,ce=>ce,c_out=>c_out,s=>s);
process(clk)
begin
clk<=not clk after 10 ns;
end process;
process
begin
a<="10001010101010";
b<="10001010101010";
wait for 30 ns;
a<="10001010101010";
b<="10001010101010";
wait for 30 ns;

wait;
end process;
process
begin
ce<='1';
wait for 190ns;
ce<='0';
wait for 50 ns;


wait;
end process;

end Behavioral;




