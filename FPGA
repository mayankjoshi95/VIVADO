library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity top is
    Port ( a,b : in STD_LOGIC;
           y : out STD_LOGIC);
end top;

architecture Behavioral of top is

begin

y<=a and b;
end Behavioral;

#VHDL HAS THREE PART 1:- WHERE IT SPECIFIES LIBRARY 2:-ENTITY 3:-ARCHITECTURE
#LIBRARY IEEE :-IEEE IS FOLDER PRESENT INSIDE A DIRECTORY WHERE YOU HAVE INSTALLED A VIVADO WHICH CONSIST OF A SET OF A LIBRARY.
#USE IEEE.STD_LOGIC_1164.ALL:-FROM THAT FOLDER WE ARE USING THIS LIBRARY.(LIBRARY IS SYSTEM INDEPENDENT BUT ENTITY AND ARCHITECTURE ARE SYSTEM DEPENDENT)


#after simulation we do the RTL analysis
#RTL ANALYSIS FOR SCHEMATIC
ENTITY(SPECIFIES ABOUT INPUT AND OUTPUT PORT AND ARCHITECTURE TELL ABOUT THE LOGIC)

#SINGLE BIT REPRESENTED AS STD_LOGIC
#FOR LAST I/O PORT WE DONOT ADD SEMICOLON
#SPACE BETWEEN ARCHITECTURE AND BEGIN IS SIGNAL ,COMPONENT ,MEMEORY ETC.
=< ASSIGNMENT OPERATOR.
#FOR MORE BIT std_logic_vector(3 downto 0);
std_logic_1164:-contains std_logic and all the logic operation
numeric_std (_logic_signed or-logic_unsigned):- all the artihmetic operation(input a\can be unsigned and signed data type an =d for both we need different hardwwware)
#PRIMITIVES ARE THE FUNDAMENTAL BLOCK WHICH ARE USE DTO DEVLOP THE CIRCUIT WHICH FPGA CAN UNDERSTAND
#THE PROCESS OF CONVERSION FROM FPGA CODE TO PRIMITIVES IS HANDLED USING SYNTHESIS
#NOW SYNTHESIS HAS TRANSFORMED OUR CODE TO SOMETHING THAT FPGA UNDERSATND NOW WE HAVE TO PUT THAT ENTIRE DESIGN ON FPGA DIE SO WE NEED TO SPECIFY INPU AND OUPUT PORT SO THAT THE TOOL 
IDENTIFY THE BEST PLACE TO PLACE OUR DESIGN.
#ADD A CONSTRAINT
#SCALAR PORTS
#save contraints
#implementation
#schematic there you will see blue dot or something showing our design
#bitstream generation
#programmming an fpga
#RTL View is a Register Transfer Level graphical representation of your design. 
This representation (.ngr file produced by Xilinx Synthesis Technology (XST)) is generated by the synthesis tool
at earlier stages of a synthesis process when technology mapping is not yet completed. 
The goal of this view is to be as close as possible to the original HDL code. In the RTL view, the 
design is represented in terms of macro blocks, such as adders, multipliers, and registers. Standard combinatorial logic is mapped onto logic gates, such as AND, NAND, and OR.

#Use of Post-Synthesis View
Graphical representation of the post-synthesis (“optimized and mapped“) netlist
(.ngc file produced by XST) contains Xilinx primitives as defined in the UNISIM library, such as LUTs, DCM, I/O buffers, and flip-flops. 
The Schematic Viewer allows you to visualize the primitive properties and the constraints attached to them.
#after bitsttream put on hardware manager
#open target auto connect

# for VHDL 2008 shift operation

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity tb is
--  Port ( );
end tb;

architecture tbnew of tb is
signal temp1:std_logic_vector(3 downto 0):="1000";
signal temp2:std_logic_vector(3 downto 0):="1100";
signal res1:std_logic_vector(3 downto 0);
signal res2:std_logic_vector(3 downto 0);



begin
res1<=temp1 sll 1;#rol for rotate left
res2<=temp2 srl 2;#ror for rotate right

end tbnew;



#RELATIONAL OPERATOR =,/=,>,>=,<,<=
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;

entity tb is
--  Port ( );
end tb;

architecture tbnew of tb is
signal temp1:std_logic_vector(3 downto 0):="1001";
signal temp2:std_logic_vector(3 downto 0):="1001";



begin
assert(temp1/=temp2) report "Two numbers are equal" SEVERITY NOTE;

end tbnew;


#DIVIDE BY TWO
library IEEE;

use IEEE.STD_LOGIC_1164.ALL;

use ieee.numeric_std.all;

use ieee.std_logic_unsigned.all;

entity tb is

--  Port ( );

end tb;

architecture tbnew of tb is

signal temp1:std_logic_vector(7 downto 0):="10000000";

signal res1:std_logic_vector(7 downto 0);

signal res2:std_logic_vector(7 downto 0);

signal res3:std_logic_vector(7 downto 0);

 

begin

res1<=temp1 srl 1;

res2<=temp1 srl 2;

res3<=temp1 srl 3;

end tbnew;




#BEHAVOURAL MODELLING STYLE #IF ELSE#DEMUX
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
 
entity demux is
    Port ( din : in STD_LOGIC;
           a,b,c,d : out STD_LOGIC;
           sel : in STD_LOGIC_vector(1 downto 0));
end demux;
 
architecture Behavioral of demux is
-----component signal mem
begin
process(din,sel)
----variable
begin
a <= '0';
b <= '0';
c <= '0';
d <= '0';
 
if(sel = "00") then
a <= din;
elsif (sel = "01") then
b <= din;
elsif (sel = "10") then
c <= din;
elsif (sel = "11") then
d <= din;
else
null;
end if;
 
 
end process;
 
end Behavioral;




#MUX

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
 
entity demux is
    Port ( y : out STD_LOGIC;
           a,b,c : in STD_LOGIC;
           sel : in STD_LOGIC_vector(1 downto 0));
end demux;
 
architecture Behavioral of demux is
-----component signal mem
begin
process(a,b,c,sel)
----variable
begin
 
case (sel) is
when "00"=>
y<=a;
when "01"=>
y<=b;
when "10"=>
y<=c;
when "11"=>
y<='0';
end case;
end process;
 
end Behavioral;


#D FLIP FLOP


library ieee;
use ieee.std_logic_1164.all;
entity top is 
  port (clk:in std_logic;
        din:in std_logic;
        dout:out std_logic);
end top;
 architecture Behavioral of top is
  begin
  process(clk)
  begin
  if Rising_edge(clk)then--falling_edge
  dout<=din;
  end if;
  end process;
  end Behavioral;     



#SYNCHRONOUS RESET



library ieee;
use ieee.std_logic_1164.all;
entity top is 
  port (clk,rst:in std_logic;
        din:in std_logic;
        dout:out std_logic);
end top;
 architecture Behavioral of top is
  begin
  process(clk)
  begin
  if rising_edge(clk)then--falling_edge
   if rst='1' then
   dout<='0';
   else
    dout<=din;
  end if;
  end if;
  end process;
  end Behavioral;     



#ASYNCHRONOUS RESET

library ieee;
use ieee.std_logic_1164.all;
entity top is 
  port (clk,rst:in std_logic;
        din:in std_logic;
        dout:out std_logic);
end top;
 architecture Behavioral of top is
  begin
  process(clk,rst)
  begin
  IF rst='1' then
   dout<='0';
   
   elsif rising_edge(clk)then--falling_edge
   
    dout<=din;
  end if;
  end process;
  end Behavioral;     

#for both up down counter



library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;
entity top is 
  port (clk,rst:in std_logic;   
        up:in std_logic;
  
        dout:out std_logic_vector(7 downto 0));
end top;
 architecture Behavioral of top is
 signal temp:std_logic_vector(7 downto 0):=x"00";
  begin
  process(clk)
  begin
  
  if rising_edge(clk) then
  if rst='1' then
  temp<=x"00";
  else
  if up='1'then
  temp<=temp+1;
  elsif up='0' then
  temp<=temp-1; 
  end if;
  end if;
  end if;
  end process;
  dout<=temp;
  end Behavioral;     

#PRIORITY ENCODER 8:3



library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


entity prien is
    Port ( d0 : in STD_LOGIC;
           d1 : in STD_LOGIC;
           d2 : in STD_LOGIC;
           d3 : in STD_LOGIC;
           d4 : in STD_LOGIC;
           d5 : in STD_LOGIC;
           d6 : in STD_LOGIC;
           d7 : in STD_LOGIC;
           Q0 : out STD_LOGIC;
           Q1 : out STD_LOGIC;
           Q2 : out STD_LOGIC);
end prien;

architecture Behavioral of prien is

begin
process(d0,d1,d2,d3,d4,d5,d6,d7)
begin
if d0='1' and d1='0'and d2='0'and d3='0'and d4='0'and d5='0'and d6='0'and d7='0'then
 Q0<='0';
 Q1<='0';
 Q2<='0';
elsIF d1='1' and (d0='0' or d0='1')and d2='0'and d3='0'and d4='0'and d5='0'and d6='0'and d7='0' then
 Q0<='1';
 Q1<='0';
 Q2<='0';
 elsIF d2='1' and (d0='0' or d0='1')and (d1='0' or d1='1')and d3='0'and d4='0'and d5='0'and d6='0'and d7='0' then
  Q0<='0';
 Q1<='1';
 Q2<='0';
 elsIF d3='1' and (d0='0' or d0='1')and (d1='0' or d1='1')and (d2='0' or d2='1') and d4='0'and d5='0'and d6='0'and d7='0'then
  Q0<='1';
 Q1<='1';
 Q2<='0';
 elsIF d4='1' and (d0='0' or d0='1')and (d1='0' or d1='1')and (d2='0' or d2='1')and (d3='0' or d3='1') and d5='0'and d6='0'and d7='0'then 
 Q0<='0';
 Q1<='0';
 Q2<='1';
 elsIF d5='1' and (d0='0' or d0='1')and (d1='0' or d1='1')and (d2='0' or d2='1')and (d3='0' or d3='1')and (d4='0' or d4='1') and d6='0'and d7='0'then
  Q0<='1';
 Q1<='0';
 Q2<='1';
 elsIF d6='1' and (d0='0' or d0='1')and (d1='0' or d1='1')and (d2='0' or d2='1')and (d3='0' or d3='1')and (d4='0' or d4='1')and (d5='0' or d5='1')and d7='0' then
  Q0<='0';
 Q1<='1';
 Q2<='1';
 
elsIF d7='1' and (d0='0' or d0='1')and (d1='0' or d1='1')and (d2='0' or d2='1')and (d3='0' or d3='1')and (d4='0' or d4='1')and (d5='0' or d5='1')and (d6='0' or d6='1') then
 Q0<='1';
 Q1<='1';
 Q2<='1';
 end if ;
 end process;
end Behavioral;



#TEST BENCH

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
 
entity top is
port (
a,b : in bit_vector(3 downto 0);
y : out bit_vector(3 downto 0)
 );
end top;
 
architecture Behavioral of top is
 
begin
 
y <= a or b;
 
end Behavioral;




library ieee;
use ieee.std_logic_1164.all;


entity toptb is
end toptb;
architecture toptb2 of toptb is
component top is
port (
a,b : in bit_vector(3 downto 0);
y : out bit_vector(3 downto 0));
end component;
signal a,b:bit_vector(3 downto 0):="0000";
signal y:bit_vector(3 downto 0);

 begin
 T1: top port map(a => a,b=> b,y=>y);
 
end toptb2 ;



#FORCE CONSTANT
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
 
entity top is
port (
a,b : in bit_vector(3 downto 0);
y : out bit_vector(3 downto 0)
 );
end top;
 
architecture Behavioral of top is
 
begin
 
y <= a or b;
 
end Behavioral;




library ieee;
use ieee.std_logic_1164.all;


entity toptb is
end toptb;
architecture toptb2 of toptb is
component top is
port (
a,b : in bit_vector(3 downto 0);
y : out bit_vector(3 downto 0));
end component;
signal a,b:bit_vector(3 downto 0):="0000";
signal y:bit_vector(3 downto 0);

 begin
 T1: top port map(a => a,b=> b,y=>y);
 a<="0110" after 10 ns,"1010" after 20 ns,"0100" after 30 ns;
 b<="1111" after 10 ns,"0110" after 20 ns,"1000" after 30 ns;
end toptb2 ;






#FORCE CONSTANT WITH USE OF PROCESS

after same as before 
-- a<="0110" after 10 ns,"1010" after 20 ns,"0100" after 30 ns;
-- b<="1111" after 10 ns,"0110" after 20 ns,"1000" after 30 ns;
process
begin
wait for 10 ns;
a<="0110";
b<="1010";
wait for 10 ns;
a<="1010";
b<="0110";
wait for 10 ns;
a<="0100";
b<="1000";
wait for 10 ns;
wait;
end process;
end toptb2 ;

 
 #FORCE CLOCK 
 
 
 process(a)
begin 
a(0)<=not a(0) after 10 ns;
a(1)<=not a(1) after 20 ns;
a(2)<= not a(2) after 50 ns;
a(3) <= not a(3) after 40 ns;
end process;
process
begin
wait for 10 ns;

b<="1010";
wait for 20 ns;
b<="0110";
wait for 40 ns;
b<="1000";
wait for 50 ns;
wait;
end process;
end toptb2 ;

 
 
 
 
 #PROCEDURE 
 
 
 
 library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;

 
entity top is

end top;
 
architecture Behavioral of top is
 procedure tutorial(ir:in std_logic_vector(31 downto 0);
                     d:out std_logic_vector(31 downto 0)                   ) is
begin
d:=ir+12;
 end tutorial;
 signal i,io:std_logic_vector(31 downto 0):=(others=>'0');
 begin
 process(i)
 variable temp:std_logic_vector(31 downto 0):=(others=>'0');
 begin
 tutorial(i,temp);
io<=temp;
end process;
end Behavioral;



 
 #RECORD 
 
 
 
 
 
 library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;

 
entity top is

end top;
 
architecture Behavioral of top is
type record1 is record
a,b :std_logic;
c,d: std_logic;
end record;
constant stimuli : record1 :=('1','0','1','1');
signal a1,a2,a3:std_logic;
begin
a1<=stimuli.c;
a2<=stimuli.d;
a3<=stimuli.b;
end Behavioral;







#for multibit vector



library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.all;
use ieee.std_logic_unsigned.all;

 
entity top is

end top;
 
architecture Behavioral of top is
type record1 is record
a,b :std_logic;
c,d: std_logic_vector(3 downto 0);
end record;
constant stimuli : record1 :=('1','0',"1011","1110");
signal a1,a2:std_logic;
signal b1,b2:std_logic_vector(3 downto 0);
begin
a1<=stimuli.a;
a2<=stimuli.b;
b1<=stimuli.c;
b2<=stimuli.d;
end Behavioral;








#USING IP  catelog  adder/subtractor










LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;



entity addtb is
--  Port ( );
end addtb;

architecture Behavioral of addtb is
component c_addsub_0 IS
  PORT (
    A : IN STD_LOGIC_VECTOR(14 DOWNTO 0);
    B : IN STD_LOGIC_VECTOR(14 DOWNTO 0);
    CLK : IN STD_LOGIC;
    CE : IN STD_LOGIC;
    C_OUT : OUT STD_LOGIC;
    S : OUT STD_LOGIC_VECTOR(14 DOWNTO 0)
  );
END component;
signal a,b :std_logic_vector(14 downto 0):=(others=>'0');
signal clk,ce:std_logic:='0';
signal c_out:std_logic;
signal s:std_logic_vector(14 downto 0);
begin
A1:c_addsub_0 port map(a=>a,b=>b,clk=>clk,ce=>ce,c_out=>c_out,s=>s);
process(clk)
begin
clk<=not clk after 10 ns;
end process;
process
begin
a<="10001010101010";
b<="10001010101010";
wait for 30 ns;
a<="10001010101010";
b<="10001010101010";
wait for 30 ns;

wait;
end process;
process
begin
ce<='1';
wait for 190ns;
ce<='0';
wait for 50 ns;


wait;
end process;

end Behavioral;













#STRUCTURAL MODELING STYLE

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


entity ha is
    Port ( a,b : in STD_LOGIC;
           s,c : out STD_LOGIC);
end ha;

architecture Behavioral of ha is

begin
s<=a xor b;
c<=a and b;


end Behavioral;


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;



entity fa is
    Port ( a,b,cin : in STD_LOGIC;
           s,c : out STD_LOGIC);
end fa;

architecture Behavioral of fa is
component ha is
    Port ( a,b : in STD_LOGIC;
           s,c : out STD_LOGIC);
end component;
signal t1,t2,t3:std_logic:='0';
begin
H1: ha port map(a,b,t1,t2);
H2: ha port map(t1,cin,s,t3);
c<=t2 or t3;
end Behavioral;













#structutal modeling style 32:! mux using 8:1mux









library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
entity mux is
    Port ( d0 : in STD_LOGIC;
           d1 : in STD_LOGIC;
           d2 : in STD_LOGIC;
           d3 : in STD_LOGIC;
           d4 : in STD_LOGIC;
           d5 : in STD_LOGIC;
           d6 : in STD_LOGIC;
           d7 : in STD_LOGIC;
           s0,s1,s2 : in STD_LOGIC;
           dout: out std_logic
           );
end mux;
architecture Behavioral of mux is
signal temp: std_logic;
signal sel: std_logic_vector(2 downto 0);
begin
sel(0) <=s0;
sel(1) <=s1;
sel(2) <=s2;
process(d0,d1,d2,d3,d4,d5,d6,d7,sel)
begin

case (sel) is
when "000" =>
temp<=d0;
when "001" =>
temp<=d1;
when "010" =>
temp<=d2;
when "011" =>
temp<=d3;
when "100" =>
temp<=d4;
when "101" =>
temp<=d5;
when "110" =>
temp<=d6;
when "111" =>
temp<=d7;
when others=>
temp<='0';
end case;
end process;
dout<=temp;
end Behavioral;



#design_1_wrapper.vhd




library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
library UNISIM;
use UNISIM.VCOMPONENTS.ALL;
entity design_1_wrapper is
  port (
    d0 : in STD_LOGIC;
    d0_1 : in STD_LOGIC;
    d0_2 : in STD_LOGIC;
    d0_3 : in STD_LOGIC;
    d1 : in STD_LOGIC;
    d1_1 : in STD_LOGIC;
    d1_2 : in STD_LOGIC;
    d1_3 : in STD_LOGIC;
    d2 : in STD_LOGIC;
    d2_1 : in STD_LOGIC;
    d2_2 : in STD_LOGIC;
    d2_3 : in STD_LOGIC;
    d3 : in STD_LOGIC;
    d3_1 : in STD_LOGIC;
    d3_2 : in STD_LOGIC;
    d3_3 : in STD_LOGIC;
    d4 : in STD_LOGIC;
    d4_1 : in STD_LOGIC;
    d4_2 : in STD_LOGIC;
    d4_3 : in STD_LOGIC;
    d5 : in STD_LOGIC;
    d5_1 : in STD_LOGIC;
    d5_2 : in STD_LOGIC;
    d5_3 : in STD_LOGIC;
    d6 : in STD_LOGIC;
    d6_1 : in STD_LOGIC;
    d6_2 : in STD_LOGIC;
    d6_3 : in STD_LOGIC;
    d7 : in STD_LOGIC;
    d7_1 : in STD_LOGIC;
    d7_2 : in STD_LOGIC;
    d7_3 : in STD_LOGIC;
    dout : out STD_LOGIC;
    s0 : in STD_LOGIC;
    s0_1 : in STD_LOGIC;
    s1 : in STD_LOGIC;
    s1_1 : in STD_LOGIC;
    s2 : in STD_LOGIC
  );
end design_1_wrapper;

architecture STRUCTURE of design_1_wrapper is
  component design_1 is
  port (
    s0 : in STD_LOGIC;
    s1 : in STD_LOGIC;
    s2 : in STD_LOGIC;
    dout : out STD_LOGIC;
    d0 : in STD_LOGIC;
    d0_1 : in STD_LOGIC;
    d1 : in STD_LOGIC;
    d2 : in STD_LOGIC;
    d3 : in STD_LOGIC;
    d4 : in STD_LOGIC;
    d5 : in STD_LOGIC;
    d6 : in STD_LOGIC;
    d7 : in STD_LOGIC;
    d1_1 : in STD_LOGIC;
    d2_1 : in STD_LOGIC;
    d3_1 : in STD_LOGIC;
    d4_1 : in STD_LOGIC;
    d5_1 : in STD_LOGIC;
    d6_1 : in STD_LOGIC;
    d7_1 : in STD_LOGIC;
    d0_2 : in STD_LOGIC;
    d1_2 : in STD_LOGIC;
    d2_2 : in STD_LOGIC;
    d3_2 : in STD_LOGIC;
    d4_2 : in STD_LOGIC;
    d5_2 : in STD_LOGIC;
    d6_2 : in STD_LOGIC;
    d7_2 : in STD_LOGIC;
    d0_3 : in STD_LOGIC;
    d1_3 : in STD_LOGIC;
    d2_3 : in STD_LOGIC;
    d3_3 : in STD_LOGIC;
    d4_3 : in STD_LOGIC;
    d5_3 : in STD_LOGIC;
    d6_3 : in STD_LOGIC;
    d7_3 : in STD_LOGIC;
    s0_1 : in STD_LOGIC;
    s1_1 : in STD_LOGIC
  );
  end component design_1;
begin
design_1_i: component design_1
     port map (
      d0 => d0,
      d0_1 => d0_1,
      d0_2 => d0_2,
      d0_3 => d0_3,
      d1 => d1,
      d1_1 => d1_1,
      d1_2 => d1_2,
      d1_3 => d1_3,
      d2 => d2,
      d2_1 => d2_1,
      d2_2 => d2_2,
      d2_3 => d2_3,
      d3 => d3,
      d3_1 => d3_1,
      d3_2 => d3_2,
      d3_3 => d3_3,
      d4 => d4,
      d4_1 => d4_1,
      d4_2 => d4_2,
      d4_3 => d4_3,
      d5 => d5,
      d5_1 => d5_1,
      d5_2 => d5_2,
      d5_3 => d5_3,
      d6 => d6,
      d6_1 => d6_1,
      d6_2 => d6_2,
      d6_3 => d6_3,
      d7 => d7,
      d7_1 => d7_1,
      d7_2 => d7_2,
      d7_3 => d7_3,
      dout => dout,
      s0 => s0,
      s0_1 => s0_1,
      s1 => s1,
      s1_1 => s1_1,
      s2 => s2
    );
end STRUCTURE;


















#FSM 

MEALY 3 PROCESSS 





library IEEE;
use IEEE.STD_LOGIC_1164.ALL;



entity TP is
    Port ( clk ,din: in STD_LOGIC;
           rst : in STD_LOGIC;
           dout : out STD_LOGIC);
end TP;

architecture Behavioral of TP is
type state_type is (s0,s1);
signal state,next_state:state_type:=s0;

begin
reset_logic:process(clk)
begin
if rising_edge(clk) then
if rst='1' then
state<=s0;
else
state<=next_state;
END IF;
END IF;
end process;
next_state_logic:process(din,state)
begin
case(state) is 
when s0=>
if (din ='1') then
next_state<=s1;
else
next_state<=s0;
end if;
when s1=>
if (din='0') then
next_state<=s1;
else 
next_state<=s0;
end if;
when others=>
next_state<=s0;
end case;
end process;
output_logic:process(din,state)
begin
case(state) is
when s0=>
if (din='1') then
dout<='0';
else
dout<='0';
end if;
when s1=>
if (din='1') then
dout<='1';
else
dout<='0'; 
end if;
end case;
end process;

end Behavioral;


#TWO PROCESSS MOORE MACHINE
 
 
 
 library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


entity TP is
    Port ( clk ,din: in STD_LOGIC;
           rst : in STD_LOGIC;
           dout : out STD_LOGIC);
end TP;

architecture Behavioral of TP is
type state_type is (s0,s1);
signal state,next_state:state_type:=s0;

begin
reset_logic:process(clk)
begin
if rising_edge(clk) then
if rst='1' then
state<=s0;
else
state<=next_state;
END IF;
END IF;
end process;
next_state_logic:process(din,state)
begin
case(state) is 
when s0=>
if (din ='1') then
next_state<=s1;
dout<='0';
else
next_state<=s0;
dout<='0';
end if;
when s1=>
if (din='0') then
next_state<=s1;
dout<='0';
else 
next_state<=s0;
dout<='1';
end if;
when others=>
next_state<=s0;
end case;
end process;

end Behavioral;

#one process mealy machine
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;


entity TP is
    Port ( clk ,din: in STD_LOGIC;
           rst : in STD_LOGIC;
           dout : out STD_LOGIC);
end TP;

architecture Behavioral of TP is
type state_type is (s0,s1);
signal state:state_type:=s0;

begin
reset_logic:process(clk)
begin
if rising_edge(clk) then
if rst='1' then
state<=s0;
else
case(state) is
when s0=>
if (din ='1') then
state<=s1;
dout<='0';
else
state<=s0;
dout<='0';
end if;
when s1=>
if (din='0') then
state<=s1;
dout<='0';
else 
state<=s0;
dout<='1';
end if;
when others=>
state<=s0;
dout<='0';
end case;
end if;
end if;
end process;

end Behavioral;







#3 PROCESS MOORE MACHINE




library IEEE;
use IEEE.STD_LOGIC_1164.ALL;



entity MOORE is
    Port ( clk : in STD_LOGIC;
           rst : in STD_LOGIC;
           dout : out STD_LOGIC;
           din : in STD_LOGIC);
end MOORE;

architecture Behavioral of MOORE is
type state_type is (s0,s1);
signal state,next_state:state_type:=s0;

begin

reset:process(clk)
begin
if rising_edge(clk)then
if (rst='1') then
state<=s0;
else 
state<=next_state;
end if;
end if;
end process;


  
process(state,din)
begin
case(state) is
when  s0 =>
if din='1' then
next_state<=s1;
else
next_state<=s0;
end if;
when  s1 =>
if din='1' then
next_state<=s0;
else
next_state<=s1;
end if;
end case;
end process;

output_logic:process(state)
begin
if state=s0 then
dout<='0';
elsif state=s1 then
dout<='1';
else
dout<='0';
end if;
end process;


end Behavioral;





#2 PROCESS MOORE MACHINE

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;



entity MOORE is
    Port ( clk : in STD_LOGIC;
           rst : in STD_LOGIC;
           dout : out STD_LOGIC;
           din : in STD_LOGIC);
end MOORE;

architecture Behavioral of MOORE is
type state_type is (s0,s1);
signal state,next_state:state_type:=s0;

begin

reset:process(clk)
begin
if rising_edge(clk)then
if (rst='1') then
state<=s0;
else 
state<=next_state;
end if;
end if;
end process;


  
process(state,din)
begin
case(state) is
when  s0 =>
dout<='0';
if din='1' then
next_state<=s1;
else
next_state<=s0;
end if;
when  s1 =>
dout<='1';
if din='1' then
next_state<=s0;
else
next_state<=s1;
end if;
when others =>
dout<='0';
next_state<=s0;

end case;
end process;



end Behavioral;




#SINGLE PROCESS METHODOLOGY



library IEEE;
use IEEE.STD_LOGIC_1164.ALL;



entity MOORE is
    Port ( clk : in STD_LOGIC;
           rst : in STD_LOGIC;
           dout : out STD_LOGIC;
           din : in STD_LOGIC);
end MOORE;

architecture Behavioral of MOORE is
type state_type is (s0,s1);
signal state:state_type:=s0;

begin

reset:process(clk)
begin
if rising_edge(clk)then
if (rst='1') then
state<=s0;
else 
case(state) is
when  s0 =>
dout<='0';
if din='1' then
state<=s1;
else
state<=s0;
end if;
when  s1 =>
dout<='1';
if din='1' then
state<=s0;
else
state<=s1;
end if;
when others=>
dout<='0';
state<=s0;
end case ;
end if ;
end if ;
end process;
end Behavioral;





#OVERLAPPING SSEQUENCE DETECTOR


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
 
 
entity top is
    Port ( clk,rst, din : in STD_LOGIC;
           dout : out STD_LOGIC);
end top;
 
architecture Behavioral of top is
type state_type is (s0,s1,s2,s3);
signal state, next_state : state_type := s0;
begin
 
reset_logic: process(clk)
begin
if(rising_edge(clk)) then
   if(rst = '1') then
     state <= s0;
   else 
     state <= next_state;
   end if;
end if;
end process;
 
next_state_logic: process(state,din)
begin
case(state) is
when s0 => 
 if(din = '1') then
    next_state <= s1;
    dout <= '0';
 else
    next_state <= s0;
    dout <= '0';
 end if;
     
when s1 => 
 if(din = '0') then
    next_state <= s2;
    dout <= '0';   
 else
    next_state <= s1;
    dout <= '0';   
 end if;
 
 when s2 => 
 if(din = '1') then
    next_state <= s3;
    dout <= '0';   
 else
    next_state <= s0;
    dout <= '0';   
 end if;
 
 
 when s3 => 
 if(din = '1') then
    next_state <= s1;
    dout <= '1';   
 else
    next_state <= s2;
    dout <= '0';   
 end if;
 
 when others =>
   next_state <= s0;
   dout <= '0';
    
end case;
end process;
end Behavioral;








#TRAFFIC CONTROL 

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;



entity tf is
    Port ( clk : in STD_LOGIC;
           rst : in STD_LOGIC;
           r : out STD_LOGIC;
           y : out STD_LOGIC;
           g : out STD_LOGIC);
end tf;

architecture Behavioral of tf is
type state_type is (idle,s0,s1,s2);
signal state:state_type:=s0;
signal count: integer range 0 to 10:=0;
begin
process(clk)
begin
if rising_edge(clk) then
  if rst='1' then
    state<=idle;
   else
   case(state) is
   when idle=>
   r<='0';
   y<='0';
   g<='0';
   state<=s0;
   when s0=>
   r<='1';
   y<='0';
   g<='0';
   if count<5 then
   count<=count+1;
   state<=s0;
   else
   count<=0;
   state<=s1;
   end if;
   
   when s1=>
   r<='0';
   y<='1';
   g<='0';
   if count<3 then
   count<=count+1;
   state<=s1;
   else
   count<=0;
   state<=s2;
   end if;
   
   when s2=>
   r<='0';
   y<='0';
   g<='1';
   if count<7 then
   count<=count+1;
   state<=s2;
   else
   count<=0;
   state<=s0;
   end if;
   when others=>
   state<=s0;
   r<='0';
   y<='0';
   g<='0';
end case;
end if;
end if;
end process;
end Behavioral;


